// QlibÈáèÂåñÁ†îÁ©∂Â∑•‰ΩúÊµÅ - Ê†∏ÂøÉÂºïÊìé
const { useState, useEffect } = React;

const QlibWorkflow = ({ 
    onNavigate = () => {},
    onAddTask = () => {},
    savedFactors = [],
    models = [],
    onAddModel = () => {},
    datasets = []
}) => {
    const [activeStep, setActiveStep] = useState(0);
    const [pipeline, setPipeline] = useState({
        data: {
            provider_uri: '~/.qlib/qlib_data/cn_data',
            region: 'cn',
            market: 'csi300',
            benchmark: 'SH000300',
            start_time: '2018-01-01',
            end_time: '2023-12-31'
        },
        features: {
            handler: 'Alpha158',
            factors: [],
            label: 'Ref($close, -1) / $close - 1'
        },
        model: {
            class: 'LightGBM',
            params: {
                n_estimators: 200,
                learning_rate: 0.1,
                max_depth: 6,
                seed: 2024
            },
            segments: {
                train: ['2018-01-01', '2021-12-31'],
                valid: ['2022-01-01', '2022-12-31'], 
                test: ['2023-01-01', '2023-12-31']
            }
        },
        strategy: {
            class: 'TopkDropoutStrategy',
            params: {
                topk: 50,
                n_drop: 5
            }
        },
        backtest: {
            start_time: '2023-01-01',
            end_time: '2023-12-31',
            account: 100000000,
            benchmark: 'SH000300',
            exchange: {
                limit_threshold: 0.095,
                deal_price: 'close',
                open_cost: 0.0005,
                close_cost: 0.0015,
                min_cost: 5
            }
        }
    });

    const [isRunning, setIsRunning] = useState(false);
    const [runProgress, setRunProgress] = useState(0);
    const [runResults, setRunResults] = useState(null);
    const [generatedConfig, setGeneratedConfig] = useState('');

    // Â∑•‰ΩúÊµÅÊ≠•È™§ÂÆö‰πâ
    const workflowSteps = [
        {
            key: 'data',
            title: 'qlibÊï∞ÊçÆÈÖçÁΩÆ',
            icon: 'üíæ',
            desc: 'ÈÖçÁΩÆqlibÊï∞ÊçÆÊ∫êÂíåËÇ°Á•®Ê±†',
            status: 'completed'
        },
        {
            key: 'features',
            title: 'ÁâπÂæÅÂ∑•Á®ã',
            icon: 'üßÆ', 
            desc: 'ÈÄâÊã©Âõ†Â≠êÂíåÁâπÂæÅÂ§ÑÁêÜ',
            status: 'pending'
        },
        {
            key: 'model',
            title: 'qlibÊ®°ÂûãËÆ≠ÁªÉ',
            icon: 'ü§ñ',
            desc: 'ÈÖçÁΩÆÂíåËÆ≠ÁªÉÈ¢ÑÊµãÊ®°Âûã',
            status: 'pending'
        },
        {
            key: 'strategy',
            title: 'ÊäïËµÑÁ≠ñÁï•',
            icon: 'üìà',
            desc: 'ÈÖçÁΩÆ‰∫§ÊòìÁ≠ñÁï•ÂíåÂèÇÊï∞',
            status: 'pending'
        },
        {
            key: 'backtest',
            title: 'Á≠ñÁï•ÂõûÊµã',
            icon: 'üéØ',
            desc: 'ÊâßË°åÂõûÊµãÂíåÊÄßËÉΩÂàÜÊûê',
            status: 'pending'
        }
    ];

    // qlibÈ¢ÑËÆæÈÖçÁΩÆ
    const qlibPresets = {
        datasets: [
            { value: 'csi300', label: 'CSI300 - Ê≤™Ê∑±300ÊàêÂàÜËÇ°', desc: 'qlibÂÜÖÁΩÆ‰∏≠ÂõΩAËÇ°‰∏ªË¶ÅÊåáÊï∞' },
            { value: 'csi500', label: 'CSI500 - ‰∏≠ËØÅ500', desc: 'qlibÂÜÖÁΩÆ‰∏≠ÁõòËÇ°ÊåáÊï∞' },
            { value: 'all', label: 'All - ÂÖ®AËÇ°Â∏ÇÂú∫', desc: 'qlibÂÖ®Â∏ÇÂú∫ËÇ°Á•®Êï∞ÊçÆ' }
        ],
        handlers: [
            { value: 'Alpha158', label: 'Alpha158 - qlibÁªèÂÖ∏158Âõ†Â≠ê', desc: 'ÂåÖÂê´‰ª∑Ê†º„ÄÅÊàê‰∫§Èáè„ÄÅÊäÄÊúØÊåáÊ†áÁ≠â158‰∏™Âõ†Â≠ê' },
            { value: 'Alpha360', label: 'Alpha360 - qlibÂ¢ûÂº∫360Âõ†Â≠ê', desc: 'Êâ©Â±ïÁöÑ360‰∏™ÁªºÂêàÂõ†Â≠êÂ∫ì' },
            { value: 'Alpha101', label: 'Alpha101 - WorldQuant101Âõ†Â≠ê', desc: 'WorldQuantÂºÄÊ∫êÁöÑ101‰∏™ÁªèÂÖ∏Âõ†Â≠ê' }
        ],
        models: [
            { value: 'LightGBM', label: 'LightGBM - Ê¢ØÂ∫¶ÊèêÂçáÊ†ë', desc: 'qlib‰ºòÂåñÁöÑLightGBMÂÆûÁé∞ÔºåÈÄÇÂêàË°®Ê†ºÊï∞ÊçÆ' },
            { value: 'CatBoost', label: 'CatBoost - Á±ªÂà´ÊèêÂçá', desc: 'YandexÂºÄÂèëÁöÑÊ¢ØÂ∫¶ÊèêÂçáÁÆóÊ≥ï' },
            { value: 'XGBoost', label: 'XGBoost - ÊûÅÁ´ØÊ¢ØÂ∫¶ÊèêÂçá', desc: 'ÁªèÂÖ∏ÁöÑÊ¢ØÂ∫¶ÊèêÂçáÊ°ÜÊû∂' },
            { value: 'Linear', label: 'Linear - Á∫øÊÄßÂõûÂΩí', desc: 'ÁÆÄÂçïÂø´ÈÄüÁöÑÁ∫øÊÄßÊ®°Âûã' },
            { value: 'MLP', label: 'MLP - Â§öÂ±ÇÊÑüÁü•Êú∫', desc: 'qlibÂÜÖÁΩÆÁöÑÊ∑±Â∫¶Â≠¶‰π†Ê®°Âûã' },
            { value: 'LSTM', label: 'LSTM - ÈïøÁü≠ÊúüËÆ∞ÂøÜÁΩëÁªú', desc: 'Êó∂Â∫èÊï∞ÊçÆÁöÑÊ∑±Â∫¶Â≠¶‰π†Ê®°Âûã' }
        ],
        strategies: [
            { value: 'TopkDropoutStrategy', label: 'TopKÈÄâËÇ°Á≠ñÁï•', desc: 'qlibÁªèÂÖ∏ÁöÑTopKÈÄâËÇ°+DropoutÁ≠ñÁï•' },
            { value: 'WeightStrategyBase', label: 'ÊùÉÈáçÂàÜÈÖçÁ≠ñÁï•', desc: 'Âü∫‰∫éÊ®°ÂûãÈ¢ÑÊµãÁöÑÊùÉÈáçÂàÜÈÖç' },
            { value: 'EnhancedIndexingStrategy', label: 'Â¢ûÂº∫ÊåáÊï∞Á≠ñÁï•', desc: 'ÊåáÊï∞Â¢ûÂº∫ÂûãÊäïËµÑÁ≠ñÁï•' }
        ]
    };

    // Êõ¥Êñ∞ÊµÅÊ∞¥Á∫øÈÖçÁΩÆ
    const updatePipeline = (step, config) => {
        setPipeline(prev => ({
            ...prev,
            [step]: { ...prev[step], ...config }
        }));
    };

    // ÁîüÊàêqlibÈÖçÁΩÆ
    const generateQlibConfig = () => {
        const config = `# qlibÈáèÂåñÁ†îÁ©∂Â∑•‰ΩúÊµÅÈÖçÁΩÆ
# Ê≠§ÈÖçÁΩÆÊñá‰ª∂ÂèØÁõ¥Êé•Áî®‰∫éqrunÂëΩ‰ª§ÊâßË°å

# qlibÂàùÂßãÂåñ
qlib_init:
    provider_uri: ${pipeline.data.provider_uri}
    region: ${pipeline.data.region}

market: ${pipeline.data.market}
benchmark: ${pipeline.data.benchmark}

# Êï∞ÊçÆÂ§ÑÁêÜÈÖçÁΩÆ
data_handler_config:
    start_time: ${pipeline.data.start_time}
    end_time: ${pipeline.data.end_time}
    fit_start_time: ${pipeline.data.start_time}
    fit_end_time: ${pipeline.model.segments.train[1]}
    instruments: market
    label: ["${pipeline.features.label}"]

# Ê®°ÂûãËÆ≠ÁªÉ‰ªªÂä°
task:
    model:
        class: ${pipeline.model.class}
        module_path: qlib.contrib.model.gbdt
        kwargs:
            n_estimators: ${pipeline.model.params.n_estimators}
            learning_rate: ${pipeline.model.params.learning_rate}
            max_depth: ${pipeline.model.params.max_depth}
            seed: ${pipeline.model.params.seed}

    dataset:
        class: DatasetH
        module_path: qlib.data.dataset
        kwargs:
            handler:
                class: ${pipeline.features.handler}
                module_path: qlib.contrib.data.handler
                kwargs: {}
            
            segments:
                train: [${pipeline.model.segments.train[0]}, ${pipeline.model.segments.train[1]}]
                valid: [${pipeline.model.segments.valid[0]}, ${pipeline.model.segments.valid[1]}]
                test: [${pipeline.model.segments.test[0]}, ${pipeline.model.segments.test[1]}]

# Á≠ñÁï•ÂõûÊµãÈÖçÁΩÆ
port_analysis_config:
    strategy:
        class: ${pipeline.strategy.class}
        module_path: qlib.contrib.strategy
        kwargs:
            topk: ${pipeline.strategy.params.topk}
            n_drop: ${pipeline.strategy.params.n_drop}

    backtest:
        start_time: ${pipeline.backtest.start_time}
        end_time: ${pipeline.backtest.end_time}
        account: ${pipeline.backtest.account}
        benchmark: ${pipeline.backtest.benchmark}
        exchange_kwargs:
            limit_threshold: ${pipeline.backtest.exchange.limit_threshold}
            deal_price: ${pipeline.backtest.exchange.deal_price}
            open_cost: ${pipeline.backtest.exchange.open_cost}
            close_cost: ${pipeline.backtest.exchange.close_cost}
            min_cost: ${pipeline.backtest.exchange.min_cost}`;

        setGeneratedConfig(config);
        return config;
    };

    // ËøêË°åqlibÂ∑•‰ΩúÊµÅ
    const runQlibWorkflow = async () => {
        setIsRunning(true);
        setRunProgress(0);

        const progressSteps = [
            { progress: 15, message: 'ÂàùÂßãÂåñqlibÁéØÂ¢É...', detail: 'Âä†ËΩΩÊï∞ÊçÆÊ∫êÈÖçÁΩÆ' },
            { progress: 30, message: 'Âä†ËΩΩËÇ°Á•®Êï∞ÊçÆ...', detail: `Â§ÑÁêÜ${pipeline.data.market}Êï∞ÊçÆÈõÜ` },
            { progress: 45, message: 'ÁâπÂæÅÂ∑•Á®ã...', detail: `ËÆ°ÁÆó${pipeline.features.handler}Âõ†Â≠ê` },
            { progress: 60, message: 'ËÆ≠ÁªÉÊ®°Âûã...', detail: `‰ΩøÁî®${pipeline.model.class}ÁÆóÊ≥ï` },
            { progress: 75, message: 'Á≠ñÁï•ÈÖçÁΩÆ...', detail: `ÈÖçÁΩÆ${pipeline.strategy.class}Á≠ñÁï•` },
            { progress: 90, message: 'ÊâßË°åÂõûÊµã...', detail: 'ËÆ°ÁÆóÁ≠ñÁï•Êî∂ÁõäÂíåÈ£éÈô©ÊåáÊ†á' },
            { progress: 100, message: 'ÁîüÊàêÂàÜÊûêÊä•Âëä...', detail: 'ÂÆåÊàêÈáèÂåñÁ†îÁ©∂ÊµÅÁ®ã' }
        ];

        for (const step of progressSteps) {
            await new Promise(resolve => setTimeout(resolve, 2000));
            setRunProgress(step.progress);
        }

        // Ê®°ÊãüqlibËøêË°åÁªìÊûú
        const mockResults = {
            model_performance: {
                train_ic: 0.0456,
                valid_ic: 0.0398,
                test_ic: 0.0367,
                train_rank_ic: 0.0612,
                valid_rank_ic: 0.0534,
                test_rank_ic: 0.0489,
                model_path: `/qlib/models/${pipeline.model.class}_${Date.now()}.pkl`
            },
            strategy_performance: {
                annual_return: 0.1847,
                benchmark_return: 0.0956,
                excess_return: 0.0891,
                volatility: 0.1623,
                sharpe_ratio: 1.138,
                information_ratio: 0.549,
                max_drawdown: -0.0847,
                win_rate: 0.574,
                calmar_ratio: 2.18
            },
            backtest_details: {
                total_trades: 2341,
                avg_holding_days: 8.7,
                turnover_rate: 0.234,
                trading_cost: 0.0156,
                net_return: 0.1691
            },
            factor_analysis: {
                top_factors: [
                    { name: 'RESI5', ic: 0.0423, weight: 0.125 },
                    { name: 'WVMA5', ic: 0.0389, weight: 0.098 },
                    { name: 'RSQR10', ic: 0.0356, weight: 0.087 },
                    { name: 'CORR20', ic: 0.0341, weight: 0.076 },
                    { name: 'STD20', ic: 0.0298, weight: 0.065 }
                ]
            }
        };

        setRunResults(mockResults);
        setIsRunning(false);

        // Ê∑ªÂä†Âà∞‰ªªÂä°ÈòüÂàó
        onAddTask({
            name: `qlibÈáèÂåñÁ†îÁ©∂ - ${pipeline.data.market.toUpperCase()}`,
            type: 'qlib_workflow',
            pipeline: pipeline,
            results: mockResults,
            config: generateQlibConfig(),
            status: 'completed'
        });
    };

    // Ê∏≤ÊüìÊï∞ÊçÆÈÖçÁΩÆÊ≠•È™§
    const renderDataStep = () => (
        <div className="step-content">
            <h3>üíæ qlibÊï∞ÊçÆÈÖçÁΩÆ</h3>
            
            <div className="config-sections">
                <div className="config-section">
                    <h4>Êï∞ÊçÆÊ∫êÈÖçÁΩÆ</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>qlibÊï∞ÊçÆË∑ØÂæÑ</label>
                            <input
                                type="text"
                                value={pipeline.data.provider_uri}
                                onChange={(e) => updatePipeline('data', { provider_uri: e.target.value })}
                                className="form-input"
                            />
                            <div className="form-hint">ËØ∑Á°Æ‰øùqlibÊï∞ÊçÆÂ∑≤Ê≠£Á°ÆÂàùÂßãÂåñ</div>
                        </div>
                        
                        <div className="form-group">
                            <label>Â∏ÇÂú∫Âå∫Âüü</label>
                            <select
                                value={pipeline.data.region}
                                onChange={(e) => updatePipeline('data', { region: e.target.value })}
                                className="form-select"
                            >
                                <option value="cn">cn - ‰∏≠ÂõΩAËÇ°Â∏ÇÂú∫</option>
                                <option value="us">us - ÁæéÂõΩËÇ°Á•®Â∏ÇÂú∫</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div className="config-section">
                    <h4>ËÇ°Á•®Ê±†ÂíåÂü∫ÂáÜ</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>ËÇ°Á•®Ê±†</label>
                            <select
                                value={pipeline.data.market}
                                onChange={(e) => updatePipeline('data', { market: e.target.value })}
                                className="form-select"
                            >
                                {qlibPresets.datasets.map(dataset => (
                                    <option key={dataset.value} value={dataset.value}>
                                        {dataset.label}
                                    </option>
                                ))}
                            </select>
                            <div className="form-hint">ÈÄâÊã©qlibÂÜÖÁΩÆÁöÑËÇ°Á•®Êï∞ÊçÆÈõÜ</div>
                        </div>

                        <div className="form-group">
                            <label>Âü∫ÂáÜÊåáÊï∞</label>
                            <input
                                type="text"
                                value={pipeline.data.benchmark}
                                onChange={(e) => updatePipeline('data', { benchmark: e.target.value })}
                                className="form-input"
                                placeholder="Â¶Ç: SH000300"
                            />
                        </div>
                    </div>
                </div>

                <div className="config-section">
                    <h4>Êó∂Èó¥ËåÉÂõ¥</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>ÂºÄÂßãÊó∂Èó¥</label>
                            <input
                                type="date"
                                value={pipeline.data.start_time}
                                onChange={(e) => updatePipeline('data', { start_time: e.target.value })}
                                className="form-input"
                            />
                        </div>

                        <div className="form-group">
                            <label>ÁªìÊùüÊó∂Èó¥</label>
                            <input
                                type="date"
                                value={pipeline.data.end_time}
                                onChange={(e) => updatePipeline('data', { end_time: e.target.value })}
                                className="form-input"
                            />
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );

    // Ê∏≤ÊüìÁâπÂæÅÂ∑•Á®ãÊ≠•È™§
    const renderFeaturesStep = () => (
        <div className="step-content">
            <h3>üßÆ ÁâπÂæÅÂ∑•Á®ã</h3>
            
            <div className="config-sections">
                <div className="config-section">
                    <h4>qlibÂõ†Â≠êÂ∫ì</h4>
                    <div className="form-group">
                        <label>ÈÄâÊã©Âõ†Â≠êÂ§ÑÁêÜÂô®</label>
                        <select
                            value={pipeline.features.handler}
                            onChange={(e) => updatePipeline('features', { handler: e.target.value })}
                            className="form-select"
                        >
                            {qlibPresets.handlers.map(handler => (
                                <option key={handler.value} value={handler.value}>
                                    {handler.label}
                                </option>
                            ))}
                        </select>
                        <div className="form-hint">qlibÂÜÖÁΩÆÁöÑÂõ†Â≠êÂ§ÑÁêÜÂô®ÔºåÂåÖÂê´È¢ÑÂÆö‰πâÁöÑÊäÄÊúØÊåáÊ†á</div>
                    </div>
                </div>

                <div className="config-section">
                    <h4>Ëá™ÂÆö‰πâÂõ†Â≠ê</h4>
                    <div className="custom-factors">
                        {savedFactors.length > 0 ? (
                            <div className="factors-list">
                                <label>ÈÄâÊã©Â∑≤‰øùÂ≠òÁöÑÂõ†Â≠ê:</label>
                                {savedFactors.map(factor => (
                                    <div key={factor.id} className="factor-item">
                                        <input
                                            type="checkbox"
                                            id={factor.id}
                                            checked={pipeline.features.factors?.some(f => f.id === factor.id) || false}
                                            onChange={(e) => {
                                                const factors = pipeline.features.factors || [];
                                                if (e.target.checked) {
                                                    updatePipeline('features', {
                                                        factors: [...factors, factor]
                                                    });
                                                } else {
                                                    updatePipeline('features', {
                                                        factors: factors.filter(f => f.id !== factor.id)
                                                    });
                                                }
                                            }}
                                        />
                                        <label htmlFor={factor.id}>
                                            <strong>{factor.name}</strong>
                                            <div className="factor-expression">{factor.expression}</div>
                                        </label>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="no-factors">
                                <p>ÊöÇÊó†Ëá™ÂÆö‰πâÂõ†Â≠ê</p>
                                <button 
                                    className="btn-secondary btn-sm"
                                    onClick={() => onNavigate('factor')}
                                >
                                    ÂâçÂæÄÂõ†Â≠êÁ†îÁ©∂
                                </button>
                            </div>
                        )}
                    </div>
                </div>

                <div className="config-section">
                    <h4>Ê†áÁ≠æÂÆö‰πâ</h4>
                    <div className="form-group">
                        <label>È¢ÑÊµãÁõÆÊ†á (Y)</label>
                        <input
                            type="text"
                            value={pipeline.features.label}
                            onChange={(e) => updatePipeline('features', { label: e.target.value })}
                            className="form-input"
                            placeholder="Â¶Ç: Ref($close, -1) / $close - 1"
                        />
                        <div className="form-hint">ÂÆö‰πâÊú∫Âô®Â≠¶‰π†ÁöÑÈ¢ÑÊµãÁõÆÊ†áÔºåÈÄöÂ∏∏‰∏∫Êú™Êù•Êî∂ÁõäÁéá</div>
                    </div>
                </div>
            </div>
        </div>
    );

    // Ê∏≤ÊüìÊ®°ÂûãËÆ≠ÁªÉÊ≠•È™§
    const renderModelStep = () => (
        <div className="step-content">
            <h3>ü§ñ qlibÊ®°ÂûãËÆ≠ÁªÉ</h3>
            
            <div className="config-sections">
                <div className="config-section">
                    <h4>Ê®°ÂûãÈÄâÊã©</h4>
                    <div className="model-options">
                        {qlibPresets.models.map(model => (
                            <div 
                                key={model.value}
                                className={`model-card ${pipeline.model.class === model.value ? 'selected' : ''}`}
                                onClick={() => updatePipeline('model', { class: model.value })}
                            >
                                <div className="model-name">{model.label}</div>
                                <div className="model-desc">{model.desc}</div>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="config-section">
                    <h4>Ê®°ÂûãÂèÇÊï∞</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>Ê†ëÁöÑÊï∞Èáè/Ëø≠‰ª£Ê¨°Êï∞</label>
                            <input
                                type="number"
                                value={pipeline.model.params.n_estimators}
                                onChange={(e) => updatePipeline('model', {
                                    params: { ...pipeline.model.params, n_estimators: parseInt(e.target.value) }
                                })}
                                className="form-input"
                                min="10" max="1000"
                            />
                        </div>

                        <div className="form-group">
                            <label>Â≠¶‰π†Áéá</label>
                            <input
                                type="number"
                                value={pipeline.model.params.learning_rate}
                                onChange={(e) => updatePipeline('model', {
                                    params: { ...pipeline.model.params, learning_rate: parseFloat(e.target.value) }
                                })}
                                className="form-input"
                                min="0.001" max="1" step="0.001"
                            />
                        </div>

                        <div className="form-group">
                            <label>ÊúÄÂ§ßÊ∑±Â∫¶</label>
                            <input
                                type="number"
                                value={pipeline.model.params.max_depth}
                                onChange={(e) => updatePipeline('model', {
                                    params: { ...pipeline.model.params, max_depth: parseInt(e.target.value) }
                                })}
                                className="form-input"
                                min="1" max="20"
                            />
                        </div>

                        <div className="form-group">
                            <label>ÈöèÊú∫ÁßçÂ≠ê</label>
                            <input
                                type="number"
                                value={pipeline.model.params.seed}
                                onChange={(e) => updatePipeline('model', {
                                    params: { ...pipeline.model.params, seed: parseInt(e.target.value) }
                                })}
                                className="form-input"
                            />
                        </div>
                    </div>
                </div>

                <div className="config-section">
                    <h4>Êï∞ÊçÆÂàÜÂâ≤</h4>
                    <div className="segments-config">
                        <div className="segment-group">
                            <label>ËÆ≠ÁªÉÈõÜ</label>
                            <div className="date-range">
                                <input
                                    type="date"
                                    value={pipeline.model.segments.train[0]}
                                    onChange={(e) => updatePipeline('model', {
                                        segments: {
                                            ...pipeline.model.segments,
                                            train: [e.target.value, pipeline.model.segments.train[1]]
                                        }
                                    })}
                                    className="form-input"
                                />
                                <span>Ëá≥</span>
                                <input
                                    type="date"
                                    value={pipeline.model.segments.train[1]}
                                    onChange={(e) => updatePipeline('model', {
                                        segments: {
                                            ...pipeline.model.segments,
                                            train: [pipeline.model.segments.train[0], e.target.value]
                                        }
                                    })}
                                    className="form-input"
                                />
                            </div>
                        </div>

                        <div className="segment-group">
                            <label>È™åËØÅÈõÜ</label>
                            <div className="date-range">
                                <input
                                    type="date"
                                    value={pipeline.model.segments.valid[0]}
                                    onChange={(e) => updatePipeline('model', {
                                        segments: {
                                            ...pipeline.model.segments,
                                            valid: [e.target.value, pipeline.model.segments.valid[1]]
                                        }
                                    })}
                                    className="form-input"
                                />
                                <span>Ëá≥</span>
                                <input
                                    type="date"
                                    value={pipeline.model.segments.valid[1]}
                                    onChange={(e) => updatePipeline('model', {
                                        segments: {
                                            ...pipeline.model.segments,
                                            valid: [pipeline.model.segments.valid[0], e.target.value]
                                        }
                                    })}
                                    className="form-input"
                                />
                            </div>
                        </div>

                        <div className="segment-group">
                            <label>ÊµãËØïÈõÜ</label>
                            <div className="date-range">
                                <input
                                    type="date"
                                    value={pipeline.model.segments.test[0]}
                                    onChange={(e) => updatePipeline('model', {
                                        segments: {
                                            ...pipeline.model.segments,
                                            test: [e.target.value, pipeline.model.segments.test[1]]
                                        }
                                    })}
                                    className="form-input"
                                />
                                <span>Ëá≥</span>
                                <input
                                    type="date"
                                    value={pipeline.model.segments.test[1]}
                                    onChange={(e) => updatePipeline('model', {
                                        segments: {
                                            ...pipeline.model.segments,
                                            test: [pipeline.model.segments.test[0], e.target.value]
                                        }
                                    })}
                                    className="form-input"
                                />
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );

    // Ê∏≤ÊüìÁ≠ñÁï•ÈÖçÁΩÆÊ≠•È™§
    const renderStrategyStep = () => (
        <div className="step-content">
            <h3>üìà ÊäïËµÑÁ≠ñÁï•ÈÖçÁΩÆ</h3>
            
            <div className="config-sections">
                <div className="config-section">
                    <h4>Á≠ñÁï•Á±ªÂûã</h4>
                    <div className="strategy-options">
                        {qlibPresets.strategies.map(strategy => (
                            <div
                                key={strategy.value}
                                className={`strategy-card ${pipeline.strategy.class === strategy.value ? 'selected' : ''}`}
                                onClick={() => updatePipeline('strategy', { class: strategy.value })}
                            >
                                <div className="strategy-name">{strategy.label}</div>
                                <div className="strategy-desc">{strategy.desc}</div>
                            </div>
                        ))}
                    </div>
                </div>

                <div className="config-section">
                    <h4>Á≠ñÁï•ÂèÇÊï∞</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>ÈÄâËÇ°Êï∞Èáè (TopK)</label>
                            <input
                                type="number"
                                value={pipeline.strategy.params.topk}
                                onChange={(e) => updatePipeline('strategy', {
                                    params: { ...pipeline.strategy.params, topk: parseInt(e.target.value) }
                                })}
                                className="form-input"
                                min="10" max="200"
                            />
                            <div className="form-hint">ÊØèÊúüÈÄâÊã©Ê®°ÂûãÈ¢ÑÊµãÂæóÂàÜÊúÄÈ´òÁöÑËÇ°Á•®Êï∞Èáè</div>
                        </div>

                        <div className="form-group">
                            <label>Ê∑òÊ±∞Êï∞Èáè (Dropout)</label>
                            <input
                                type="number"
                                value={pipeline.strategy.params.n_drop}
                                onChange={(e) => updatePipeline('strategy', {
                                    params: { ...pipeline.strategy.params, n_drop: parseInt(e.target.value) }
                                })}
                                className="form-input"
                                min="0" max="50"
                            />
                            <div className="form-hint">ÊØèÊúüÊ∑òÊ±∞ÊåÅ‰ªì‰∏≠ÊéíÂêçÊúÄ‰ΩéÁöÑËÇ°Á•®Êï∞Èáè</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );

    // Ê∏≤ÊüìÂõûÊµãÈÖçÁΩÆÊ≠•È™§
    const renderBacktestStep = () => (
        <div className="step-content">
            <h3>üéØ Á≠ñÁï•ÂõûÊµãÈÖçÁΩÆ</h3>
            
            <div className="config-sections">
                <div className="config-section">
                    <h4>ÂõûÊµãÊó∂Èó¥</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>ÂõûÊµãÂºÄÂßãÊó∂Èó¥</label>
                            <input
                                type="date"
                                value={pipeline.backtest.start_time}
                                onChange={(e) => updatePipeline('backtest', { start_time: e.target.value })}
                                className="form-input"
                            />
                        </div>

                        <div className="form-group">
                            <label>ÂõûÊµãÁªìÊùüÊó∂Èó¥</label>
                            <input
                                type="date"
                                value={pipeline.backtest.end_time}
                                onChange={(e) => updatePipeline('backtest', { end_time: e.target.value })}
                                className="form-input"
                            />
                        </div>
                    </div>
                </div>

                <div className="config-section">
                    <h4>ËµÑÈáëÂíåÂü∫ÂáÜ</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>ÂàùÂßãËµÑÈáë (ÂÖÉ)</label>
                            <input
                                type="number"
                                value={pipeline.backtest.account}
                                onChange={(e) => updatePipeline('backtest', { account: parseInt(e.target.value) })}
                                className="form-input"
                                step="1000000"
                            />
                        </div>

                        <div className="form-group">
                            <label>‰∏öÁª©Âü∫ÂáÜ</label>
                            <input
                                type="text"
                                value={pipeline.backtest.benchmark}
                                onChange={(e) => updatePipeline('backtest', { benchmark: e.target.value })}
                                className="form-input"
                            />
                        </div>
                    </div>
                </div>

                <div className="config-section">
                    <h4>‰∫§ÊòìÊàêÊú¨ËÆæÁΩÆ</h4>
                    <div className="form-grid">
                        <div className="form-group">
                            <label>Ê∂®Ë∑åÂÅúÈôêÂà∂</label>
                            <input
                                type="number"
                                value={pipeline.backtest.exchange.limit_threshold}
                                onChange={(e) => updatePipeline('backtest', {
                                    exchange: { ...pipeline.backtest.exchange, limit_threshold: parseFloat(e.target.value) }
                                })}
                                className="form-input"
                                step="0.001" min="0" max="0.2"
                            />
                            <div className="form-hint">0.095 = 9.5%</div>
                        </div>

                        <div className="form-group">
                            <label>ÂºÄ‰ªìÊâãÁª≠Ë¥πÁéá</label>
                            <input
                                type="number"
                                value={pipeline.backtest.exchange.open_cost}
                                onChange={(e) => updatePipeline('backtest', {
                                    exchange: { ...pipeline.backtest.exchange, open_cost: parseFloat(e.target.value) }
                                })}
                                className="form-input"
                                step="0.0001" min="0" max="0.01"
                            />
                            <div className="form-hint">0.0005 = 0.05%</div>
                        </div>

                        <div className="form-group">
                            <label>Âπ≥‰ªìÊâãÁª≠Ë¥πÁéá</label>
                            <input
                                type="number"
                                value={pipeline.backtest.exchange.close_cost}
                                onChange={(e) => updatePipeline('backtest', {
                                    exchange: { ...pipeline.backtest.exchange, close_cost: parseFloat(e.target.value) }
                                })}
                                className="form-input"
                                step="0.0001" min="0" max="0.01"
                            />
                            <div className="form-hint">0.0015 = 0.15%</div>
                        </div>

                        <div className="form-group">
                            <label>ÊúÄ‰ΩéÊâãÁª≠Ë¥π (ÂÖÉ)</label>
                            <input
                                type="number"
                                value={pipeline.backtest.exchange.min_cost}
                                onChange={(e) => updatePipeline('backtest', {
                                    exchange: { ...pipeline.backtest.exchange, min_cost: parseInt(e.target.value) }
                                })}
                                className="form-input"
                                min="0"
                            />
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );

    // Ê∏≤ÊüìÂΩìÂâçÊ≠•È™§ÂÜÖÂÆπ
    const renderStepContent = () => {
        switch(activeStep) {
            case 0: return renderDataStep();
            case 1: return renderFeaturesStep();
            case 2: return renderModelStep();
            case 3: return renderStrategyStep();
            case 4: return renderBacktestStep();
            default: return renderDataStep();
        }
    };

    useEffect(() => {
        generateQlibConfig();
    }, [pipeline]);

    return (
        <div className="qlib-workflow">
            <div className="workflow-header">
                <h1>‚öôÔ∏è qlibÈáèÂåñÁ†îÁ©∂Â∑•‰ΩúÊµÅ</h1>
                <div className="header-subtitle">
                    Âü∫‰∫éqlibÊ°ÜÊû∂ÁöÑÁ´ØÂà∞Á´ØÈáèÂåñÊäïËµÑÁ†îÁ©∂Âπ≥Âè∞
                </div>
            </div>

            {/* Â∑•‰ΩúÊµÅÊ≠•È™§ÂØºËà™ */}
            <div className="workflow-steps">
                {workflowSteps.map((step, index) => (
                    <div
                        key={step.key}
                        className={`step-item ${index === activeStep ? 'active' : ''} ${index < activeStep ? 'completed' : ''}`}
                        onClick={() => setActiveStep(index)}
                    >
                        <div className="step-icon">{step.icon}</div>
                        <div className="step-content">
                            <div className="step-title">{step.title}</div>
                            <div className="step-desc">{step.desc}</div>
                        </div>
                        <div className="step-number">{index + 1}</div>
                        {index < workflowSteps.length - 1 && <div className="step-connector"></div>}
                    </div>
                ))}
            </div>

            {/* ‰∏ªÈÖçÁΩÆÂå∫Âüü */}
            <div className="workflow-main">
                <div className="configuration-panel">
                    {renderStepContent()}
                </div>

                {/* ÈÖçÁΩÆÈ¢ÑËßà */}
                <div className="preview-panel">
                    <div className="preview-header">
                        <h4>üìÑ qlibÈÖçÁΩÆÈ¢ÑËßà</h4>
                        <div className="preview-actions">
                            <button 
                                className="btn-secondary btn-sm"
                                onClick={() => navigator.clipboard.writeText(generatedConfig)}
                            >
                                üìã Â§çÂà∂
                            </button>
                            <button 
                                className="btn-secondary btn-sm"
                                onClick={() => {
                                    const blob = new Blob([generatedConfig], { type: 'text/yaml' });
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = `qlib_config_${Date.now()}.yaml`;
                                    a.click();
                                }}
                            >
                                üíæ ‰∏ãËΩΩ
                            </button>
                        </div>
                    </div>
                    <pre className="config-preview">{generatedConfig}</pre>
                </div>
            </div>

            {/* Êìç‰ΩúÊéßÂà∂ */}
            <div className="workflow-controls">
                <div className="controls-left">
                    {activeStep > 0 && (
                        <button 
                            className="btn-secondary"
                            onClick={() => setActiveStep(activeStep - 1)}
                        >
                            ‚Üê ‰∏ä‰∏ÄÊ≠•
                        </button>
                    )}
                </div>

                <div className="controls-right">
                    <button 
                        className="btn-success btn-large"
                        onClick={runQlibWorkflow}
                        disabled={isRunning}
                    >
                        {isRunning ? 'üîÑ ËøêË°å‰∏≠...' : 'üöÄ ËøêË°åqlibÂ∑•‰ΩúÊµÅ'}
                    </button>
                </div>
            </div>

            {/* ËøêË°åËøõÂ∫¶ */}
            {isRunning && (
                <div className="run-progress">
                    <div className="progress-header">
                        <h3>üîÑ qlibÂ∑•‰ΩúÊµÅËøêË°å‰∏≠</h3>
                        <div className="progress-percentage">{runProgress}%</div>
                    </div>
                    <div className="progress-bar">
                        <div 
                            className="progress-fill" 
                            style={{ width: `${runProgress}%` }}
                        ></div>
                    </div>
                    <div className="progress-details">
                        {runProgress <= 15 && 'ÂàùÂßãÂåñqlibÁéØÂ¢É...'}
                        {runProgress > 15 && runProgress <= 30 && `Âä†ËΩΩËÇ°Á•®Êï∞ÊçÆ... (${pipeline.data.market})`}
                        {runProgress > 30 && runProgress <= 45 && `ÁâπÂæÅÂ∑•Á®ã... (${pipeline.features.handler})`}
                        {runProgress > 45 && runProgress <= 60 && `ËÆ≠ÁªÉÊ®°Âûã... (${pipeline.model.class})`}
                        {runProgress > 60 && runProgress <= 75 && `Á≠ñÁï•ÈÖçÁΩÆ... (${pipeline.strategy.class})`}
                        {runProgress > 75 && runProgress <= 90 && 'ÊâßË°åÂõûÊµã...'}
                        {runProgress > 90 && 'ÁîüÊàêÂàÜÊûêÊä•Âëä...'}
                    </div>
                </div>
            )}

            {/* ËøêË°åÁªìÊûú */}
            {runResults && (
                <div className="run-results">
                    <div className="results-header">
                        <h3>‚úÖ qlibÂ∑•‰ΩúÊµÅÂÆåÊàê</h3>
                        <div className="results-actions">
                            <button 
                                className="btn-primary"
                                onClick={() => onNavigate('results')}
                            >
                                üìä Êü•ÁúãËØ¶ÁªÜÂàÜÊûê
                            </button>
                        </div>
                    </div>

                    <div className="results-summary">
                        <div className="result-section">
                            <h4>ü§ñ Ê®°ÂûãÊÄßËÉΩ</h4>
                            <div className="metrics-row">
                                <div className="metric-item">
                                    <span className="metric-label">ËÆ≠ÁªÉIC</span>
                                    <span className="metric-value">{runResults.model_performance.train_ic}</span>
                                </div>
                                <div className="metric-item">
                                    <span className="metric-label">È™åËØÅIC</span>
                                    <span className="metric-value">{runResults.model_performance.valid_ic}</span>
                                </div>
                                <div className="metric-item">
                                    <span className="metric-label">ÊµãËØïIC</span>
                                    <span className="metric-value">{runResults.model_performance.test_ic}</span>
                                </div>
                            </div>
                        </div>

                        <div className="result-section">
                            <h4>üìà Á≠ñÁï•Ë°®Áé∞</h4>
                            <div className="metrics-row">
                                <div className="metric-item">
                                    <span className="metric-label">Âπ¥ÂåñÊî∂Áõä</span>
                                    <span className="metric-value positive">
                                        {(runResults.strategy_performance.annual_return * 100).toFixed(2)}%
                                    </span>
                                </div>
                                <div className="metric-item">
                                    <span className="metric-label">Â§èÊôÆÊØîÁéá</span>
                                    <span className="metric-value">{runResults.strategy_performance.sharpe_ratio}</span>
                                </div>
                                <div className="metric-item">
                                    <span className="metric-label">ÊúÄÂ§ßÂõûÊí§</span>
                                    <span className="metric-value negative">
                                        {(runResults.strategy_performance.max_drawdown * 100).toFixed(2)}%
                                    </span>
                                </div>
                                <div className="metric-item">
                                    <span className="metric-label">‰ø°ÊÅØÊØîÁéá</span>
                                    <span className="metric-value">{runResults.strategy_performance.information_ratio}</span>
                                </div>
                            </div>
                        </div>

                        <div className="result-section">
                            <h4>üîç Âõ†Â≠êÂàÜÊûê</h4>
                            <div className="top-factors">
                                {runResults.factor_analysis.top_factors.slice(0, 3).map((factor, idx) => (
                                    <div key={idx} className="factor-metric">
                                        <span className="factor-name">{factor.name}</span>
                                        <span className="factor-ic">IC: {factor.ic}</span>
                                        <span className="factor-weight">ÊùÉÈáç: {(factor.weight * 100).toFixed(1)}%</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};